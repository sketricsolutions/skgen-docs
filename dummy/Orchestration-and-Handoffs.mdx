## Overview

Orchestration in SketricGen defines **how agents collaborate** inside a workflow.

Each agent operates semi-independently but follows your defined logic to decide **when** to hand off control or call another agent as a tool.

SketricGen supports both **AI-routed orchestration** (where the model decides the next step) and **designer-routed orchestration** (where you manually connect agents with explicit edges in the AgentSpace).

![Orchestration hero image showing multi-agent workflow with connected agents and handoff connections](/images/user-guides/orchestration-handoffs/orch_hero.png)

## How Routing Works (AI-Routed)

In **AI-routed orchestration**, agents decide when to hand off based on their **instructions** and **current input**, rather than following a fixed sequence.

This routing style gives agents autonomy to decide:

- Whether to continue reasoning, call a tool, or pass control to another agent.
- Which downstream agent is most appropriate for the current intent.

To achieve reliable AI-routed behavior:

- Designate a clear **entry agent** (such as “Manager” or “Triage”) to handle all first messages.
- Write **precise conditions** in the agent’s instructions describing when to hand off and when to handle the query directly.
- Keep roles distinct — avoid overlapping functions between agents.

## Handoff vs Agent-as-Tool

### Handoff (Agent → Agent)

A **handoff** transfers full control from one agent to another.

Once handed off, the target agent owns the next reasoning turn and may further hand off to others.

This way, if the input message intent is completed, the Agent in control returns the final response. So there is no fixed start and endpoint in the canvas unlike most Automations.

**Characteristics**

- Passes control of the Run permanently until another handoff occurs.
- Maintains continuity of context (structured inputs can be passed).
- Ideal for sequential or role-based pipelines (e.g., triage → specialist → responder).

### Agent-as-Tool

In this setup, an agent acts as a **callable utility** rather than a control-transfer node.

The parent agent calls it as a sub-routine, waits for it to complete, and resumes control when the result is returned.

Common use cases:

- Text classification
- Information extraction
- Summarization or redaction tasks

**Control-flow rule of thumb:**

Once handed off, a child won’t automatically return control to the parent unless you define a _handoff back_.

If the parent should remain in charge, model the secondary logic as **Agent-as-Tool** instead.

**Important:**

The agent directly connected to the **Trigger node** cannot be configured or used as an Agent-as-Tool.

![Screenshot showing agent-as-tool configuration interface for using agents as reusable components](/images/user-guides/orchestration-handoffs/orch_agent_as_tool.png)

## Writing Effective Instructions

To orchestrate reliably:

- Define each agent’s **role**, **goal**, and **handoff criteria** in its instructions.
- Provide clear logic for **when to use tools** and **when to delegate**.
- Treat your entry agent as the **gateway** for all new inputs.

Example guidance line:

“If the query requires data retrieval or document lookup, hand off to Responder; otherwise, respond directly.”

## Structuring Data Between Agents

Data flow in orchestration depends on **Structured Inputs and Outputs**.

- Use **Structured Inputs** on child agents so the parent knows exactly what to supply before a handoff.
- Use **Structured Outputs (JSON)** on final responder agents to ensure consistent output or API responses.
- Define only necessary fields; keep schemas concise.

Example:

```json
{
	"intent": "string",
	"customer_id": "integer",
	"handoff_required": "boolean"
}
```

## Reliability: Retries, Fallbacks & Traces

SketricGen provides built-in mechanisms for reliability and debugging:

- **Tool Retries:** Automatically retries failed external calls (e.g., 429 or 5xx errors).
- **Fallbacks:** Define alternate logic or backup tools for fragile endpoints.
- **Trace Explorer:** Inspect all agent interactions, tool calls, handoffs, and credit usage for each conversation.

Iterate and refine orchestration flows directly from trace data — identify bottlenecks, redundant handoffs, or misrouted intents.

![Screenshot showing trace explorer interface displaying agent execution flow, handoffs, and performance metrics](/images/user-guides/orchestration-handoffs/orch_trace.png)

## Starter Patterns (AI-Routed)

These are common multi-agent orchestration setups you can replicate or adapt:

| Pattern                                            | Description                                                                          |
| -------------------------------------------------- | ------------------------------------------------------------------------------------ |
| Manager → Researcher → Writer                      | Manager routes research tasks, Researcher compiles info, Writer drafts the response. |
| Manager → (Agent-as-Tool: Classifier) → Specialist | Classifier determines type; Specialist handles it further.                           |
| Manager → Specialist → (Agent-as-Tool: Summarizer) | Specialist processes and sends text to Summarizer for concise output.                |

![Animated GIF showing handoff configuration interface with routing options, conditions, and fallback settings](/images/user-guides/orchestration-handoffs/orch_handoff.gif)

## Why Protocols Matter

Interoperability is critical in larger multi-agent ecosystems.

- **MCP (Model Context Protocol):**
  A standardized way to expose tools and data sources safely and consistently — think of it as “USB-C for AI.”
- **A2A (Agent-to-Agent) Communication:**
  Enables secure interoperation between agents across different systems or vendors, letting workflows scale beyond a single environment.

## Best Practices

- Always define one clear **entry agent** to receive initial inputs.
- Use **handoffs** for ownership transfer and **Agent-as-Tool** for short, reusable subtasks.
- Keep handoff paths labeled and intentional.
- Validate Structured Inputs and Outputs to prevent schema mismatches.
- Review traces after each major workflow run to fine-tune orchestration.
- Keep logic simple and modular — complexity should emerge from clarity, not layers.
